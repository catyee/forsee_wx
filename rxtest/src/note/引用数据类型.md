 - 检测数组
    1. [1,2,3] instanceof Array
    2. Array.isArray([1,2,3])

 - 所有的对象都具有toLocaleString(),toString() 和 valueOf() 方法，调用数组的toString() 方法会返回数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用valueOf() 返回的还是数组。
 - 数组方法 
    - sort 接收一个比较函数
    - indexOf() 和 lastIndexOf() 接收两个参数：要查找的项和（可选的）表示要查找起点位置的索引，这两个方法都返回要查找的项在数组中的位置，没找到返回-1，在比较第一个参数与数组中的每一项时，会使用全等操作，所以说查找的项必须严格相等。
    - ECMAScipt5为数组定义了5个迭代方法，每个方法都接收两个参数: 要在每一项上运行的函数和（可选的）运行该函数的作用域对象-影响this的值，传入这些方法的函数接收三个参数：数组项的值，该项在数组中的位置和数组对象本身，
        - every(): 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true
            ```
                var numbers = [1,2,3,4,5,4,3,2,1];
                var everyResult = numbers.every(function(item.index,array){
                    return item > 2;
                })
                console.log(everyResult); // false
            ```
        - filter(): 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组
            ```
                var numbers = [1,2,3,4,5,4,3,2,1];
                var filterResult = numbers.filter(function(item,index,array){
                    return (item > 2);
                })
                console.log(filterResult); // [3,4,5,4,3]
            ```    
        - forEach(): 对数组中的每一项运行给定函数，这个方法没有返回值
            ```
                var numbers = [1,2,3,4,5,4,3,2,1];
                numbers.forEach(function(item,index,array){
                    // 执行一些操作
                })
            ```
        - map(): 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
            ```
                var numbers = [1,2,3,4,5,4,3,2,1];
                var mapResult = numbers.forEach(function(item,index,array){
                    return item*2;
                })
                console.log(mapResult); // [2,,4,6,8,10,8,6,4,2]
            ```
        - some(): 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true
            ```
                var numbers = [1,2,3,4,5,4,3,2,1];
                var someResult = numbers.some(function(item,index,array){
                    return (item>2);
                })
                console.log(someResult); // true
            ```

    以上方法都不会修改数组中包含的值

    - 数组的归并方法
    ECMAScript 5新增了两个归并数组的方法:reduce()和reduceRight(),这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。这两个方法都接收两个参数: 一个在每一项上调用的函数 和 作为归并基础的初始值(可选)，传给reduce()和reduceRight()的函数接收4个参数:前一个值、当前值、项的索引和数组对象，这个函数返回的任何值都会作为第一个参数自动传给下一项，第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项
    ```
        var values = [1,2,3,4,5];
        var sum = values.reduce(function(prev,cur,index,array){
            return prev + cur;
        })
        console.log(sum); // 15
    ```

- 正则
'\n' 字面量格式: /\\n/ RegExp构造函数模式: new RegExp('\\\\n'); RegExp构造函数模式下所有元字符都必须双重转义，已经转义过的也是

RegExp实例方法:
RegExp对象的主要方法是exec(),该方法是专门为捕获组而设计的，exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组，或者在没有匹配项的情况下返回null，返回的数组虽然是Array的实例，但是包含两个额外的属性:index(匹配项在字符串中的位置)和input(应该正则表达式的字符串),在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串(如果模式中没有捕获组，则该数组只包含一项)

- 函数
函数没有重载 可以用arguments来实现重载

    - 函数声明与函数表达式
    ```
        // 函数声明
        function sum(num1,num2){
            return num1 + num2;
        }
        // 函数表达式
        var sum = function(num1,num2){
            return num1 + num2;
        }
    ```
    实际上，解释器在向执行环境加载数据时，对函数声明和函数表达式并非一视同仁，解释器会率先读取函数声明,并在其执行任何代码之前可用（可以访问）;至于函数表达式，则必须等到解释器执行到它所在的代码行才会真正被解释执行。
    ```
        // 可以正常运行
        console.log(sum(10,10));
        function sum(num1,num2){
            return num1 + num2;
        }
        // 会报错
        console.log(sum(10,10));
        var sum = function () {
            return num1 + num2;
        }
    ```
    - 在函数内部有两个特殊的对象: arguments和this,arguments是一个类数组对象，包含传入函数的所有参数，这个对象还有一个名叫callee的属性，该属性有一个指针，指向拥有这个aeguments对象的函数
    ```
        // 阶乘函数
        function factorial(num){
            if(num < 1>){
                return 1;
            }else {
                return num*arguments.callee(num - 1)
            }
        }
    ```
    - ECMAScript5规范了另一个函数对象的属性caller,这个属性中保存着调用当前函数的函数的引用，如果在全局种调用当前函数，它的值为null

        ```
            function outer() {
                inner();
            }
            function inner() {
                console.log(inner.caller);// 或者 console.log(arguments.callee.caller) 显示outer() 函数的源代码
            }
            outer();
        ```

- ECMAScript中的函数也是对象，因此函数也有属性和方法，每个函数都包含两个属性:length和prototype
    - length属性表示函数希望接收的命名参数的个数
    - 对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的正在所在，换句话说，诸如toString()和valueOf()等方法，实际上都保存在prototype名下，只不过通过各自对象的实例访问罢了。在ECMAScirpt5中，prototype属性是不可枚举的，因此使用for-in无法发现
    - 每个函数都包含两个非继承而来的方法: apply()和call(),这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值 
        - apply() 方法接收两个参数: 一个是在其中运行函数的作用域，另一个是参数数组，其中第二个参数可以是Array实例，也可以是arguments对象。
        - call()和apply()真正强大的地方是能够扩充函数赖以运行的作用域
            ```
                window.color = "red";
                var o = {color: "blue"};
                function sayColor() {
                    console.log(this.color);
                }
                sayColor(); // red
                sayColor.call(this);// red
                sayColor.call(window); // red
                sayColor.call(o); // blue
            ```